### 一、核心术语精准定义
* 类类型（class type）：
  * struct/class/union的统称，单独的 “class” 仅指class关键字定义的类型（不含 union）；模板相关术语需遵循 “模板类型 + template” 规范（如class template），避免易歧义的template class。
* 声明（declaration）vs 定义（definition）：
  * 声明仅告知编译器 “名字存在且是什么类型”（无内存 / 实现），定义需提供完整实现或分配内存；模板的 “声明 / 定义” 看是否有 “体（{}）”，有则为定义。
* 完整类型（complete type）vs 不完整类型（incomplete type）：
  * 完整类型是已定义、大小 / 布局可确定的类型（如class C {};），不完整类型仅声明未定义（如class C;、int arr[];）；不完整类型可声明指针 / 引用，但不能创建对象、计算sizeof。
* 模板参数（template parameter）vs 模板实参（template argument）：
  * 参数是模板定义时的 “占位符”（分类型 / 非类型 / 模板模板参数），实参是实例化时的 “具体值 / 类型”；函数模板支持实参自动推导，类模板需显式传递（或用默认实参）。
* 可链接实体（linkable entity）：
  * 对链接器可见的实体，包括函数 / 成员函数、全局变量 / 静态数据成员，以及模板实例化后的上述实体；模板本身不是可链接实体，实例化后才是。
### 二、核心规则约束
单定义规则（ODR）：
* 非内联普通函数 / 全局变量：整个程序中仅能定义一次；
* 类 / 内联函数 / 模板：每个翻译单元最多定义一次，且所有翻译单元的定义必须一致；
  * 翻译单元：源文件预处理后的产物（含#include内容、宏展开结果）。
* 模板实例化与特化：
  * 实例化：编译器自动替换模板参数生成实体定义（分完全实例化 / 不完全实例化）；
  * 特化：广义指所有模板生成的具体实体，狭义指程序员用template<>编写的显式定制实现（区别于自动实例化）。
### 三、关键使用要点
* 不完整类型仅可用于声明指针 / 引用、extern数组声明，不可创建对象或计算大小；补充定义后会变为完整类型。
* 模板参数中，非类型参数必须是编译期常量（如int N=5，不能用运行时变量）；模板实参传递分显式指定、自动推导（仅函数模板）、默认实参三种方式。
* 可链接实体是 ODR 约束的核心对象，模板定义通常放在头文件，避免链接时找不到实例化后的可链接实体。