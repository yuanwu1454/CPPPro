# 堆 / 栈 / 静态区 / 常量区的区别

本文梳理编程中核心的内存区域（堆、栈、静态区、常量区）的核心差异、管理规则、存储内容及使用特点，是理解程序内存管理的基础知识点。

## 一、核心概念与区别

可以把程序运行时的内存想象成一栋功能分区的大楼，这几个区域是大楼里不同功能的房间，各自有专属的规则、用途和特性，核心区别如下表所示：

|内存区域|核心特点|管理方式|存储内容|生命周期|访问速度|
|---|---|---|---|---|---|
|栈 (Stack)|自动分配/释放，先进后出|操作系统自动管理|函数参数、局部变量、函数返回地址|随函数调用创建，函数结束销毁|极快（CPU缓存级）|
|堆 (Heap)|手动分配/释放，无序|程序员手动管理（如`new/delete`、`malloc/free`）|动态分配的对象、大数据块|从分配开始，直到手动释放或程序结束|较慢（需寻址）|
|静态区 (Static Area)|全局可见/作用域限定，固定大小|操作系统管理|全局变量、static修饰的变量|程序启动时创建，程序结束销毁|较快|
|常量区 (Constant Area)|只读，不可修改|操作系统管理|字符串常量、const修饰的常量|程序启动时创建，程序结束销毁|较快|
## 二、各内存区域详解（附C++代码示例）

### 1. 栈 (Stack)

- **通俗理解**：类似叠盘子，遵循**先进后出**规则，操作系统会自动完成空间的分配与释放，无需程序员干预。

- **核心注意**：栈的大小有限制（通常为几MB），若定义过多/过大的局部变量（如超大数组），会导致**栈溢出（Stack Overflow）**。

- **代码示例**：

```c++
#include <iostream>
using namespace std;

void stackExample() {
    int a = 10; // 局部变量a，存储在栈上
    int b = 20; // 局部变量b，存储在栈上
    cout << a + b << endl; // 输出30
} // 函数结束，栈上的a、b被操作系统自动销毁，栈空间释放

int main() {
    stackExample();
    // 此处无法访问a、b，已被销毁
    return 0;
}
```

### 2. 堆 (Heap)

- **通俗理解**：类似仓库，程序员需要**手动申请**空间（如`new`/`malloc`），使用完成后也必须**手动释放**（如`delete`/`free`），空间大小几乎仅受物理内存限制。

- **核心注意**：堆内存不会自动释放，忘记释放会造成**内存泄漏**；重复释放、释放后继续访问会导致程序崩溃或野指针问题。

- **代码示例**：

```c++
#include <iostream>
using namespace std;

int main() {
    // 手动分配堆内存，存储整型值100，返回堆空间地址
    int* p = new int(100); 
    cout << *p << endl; // 输出100
    
    delete p; // 手动释放堆内存，必须执行
    p = nullptr; // 置空指针，避免野指针

    // 堆上分配数组（5个整型元素）
    int* arr = new int[5]{1,2,3,4,5};
    delete[] arr; // 数组形式的堆释放需加[]，与分配匹配
    arr = nullptr;
    return 0;
}
```

### 3. 静态区 (Static Area)

- **通俗理解**：类似大楼的公共储物柜，程序运行期间始终存在，空间一旦分配不会中途释放；全局变量对所有函数可见，`static`修饰的局部变量仅在所在函数内可见。

- **核心注意**：静态区变量**仅初始化一次**，即使所在函数多次调用，也不会重新创建；全局变量和静态变量若未手动初始化，会被操作系统默认初始化为0。

- **代码示例**：

```c++
#include <iostream>
using namespace std;

int globalVar = 10; // 全局变量，存储在静态区

void staticExample() {
    // static局部变量：存储在静态区，仅第一次调用时初始化
    static int staticVar = 20; 
    staticVar++; // 每次调用自增，值会保留
    cout << "staticVar: " << staticVar << endl;
}

int main() {
    staticExample(); // 输出21（第一次调用，初始化后自增）
    staticExample(); // 输出22（直接自增，未重新初始化）
    cout << "globalVar: " << globalVar << endl; // 输出10
    return 0;
}
```

### 4. 常量区 (Constant Area)

- **通俗理解**：类似大楼的**只读文件柜**，存储的内容被操作系统标记为只读，任何试图修改的操作都会触发程序异常或崩溃。

- **核心注意**：`const`修饰的常量、双引号包裹的字符串常量，均存储在常量区；即使将字符串常量地址赋值给普通指针，也无法修改其内容。

- **代码示例**：

```c++
#include <iostream>
using namespace std;

int main() {
    const int constVar = 30; // const常量，存储在常量区
    cout << constVar << endl; // 输出30
    // constVar = 40; // 编译报错！常量区内容不可修改

    char* str = "hello world"; // 字符串常量存储在常量区，str指向其首地址
    cout << str << endl; // 输出hello world
    // str[0] = 'H'; // 运行崩溃！试图修改常量区只读内容
    return 0;
}
```

## 三、核心使用总结

1. **栈**：适合存储生命周期随函数的小数据（局部变量、参数），无需手动管理，注意避免栈溢出；

2. **堆**：适合存储动态大小、生命周期自定义的数据（大数组、动态对象），必须严格做好申请与释放的匹配；

3. **静态区**：适合存储程序全程需要的、无需频繁创建销毁的数据（全局配置、函数内持久化变量）；

4. **常量区**：适合存储程序中固定不变、只读的数据（字符串常量、const常量），禁止修改操作。