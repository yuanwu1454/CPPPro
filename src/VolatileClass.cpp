#include "VolatileClass.h"
#include <iostream>
using namespace  std;

// volatile的核心作用是告诉编译器「不要对这个变量进行优化」，必须每次都直接从它的内存地址中读取 / 写入数据，而不能缓存到寄存器中或者省略不必要的访问。


// volatile的核心作用是禁止编译器对变量进行访问优化，强制每次从内存地址读写数据。
// 它的核心使用场景是访问硬件寄存器和中断服务程序共享全局变量，多线程场景不推荐单独使用。
// 它存在的必要性是解决编译器优化与「变量被外部因素修改」之间的矛盾，避免程序逻辑与预期不符。


// 1. 访问硬件寄存器（最核心、最常用场景）
// 计算机的硬件设备（比如串口、定时器、传感器）通常会通过内存映射的方式，将自己的控制寄存器、状态寄存器映射到 CPU 的地址空间中。
// 这些寄存器的特点是：
// 读取它可能会改变它的值（比如「状态清除寄存器」，读取后自动清零）；
// 它的值可能会被硬件主动修改（比如定时器的「计数寄存器」，硬件会自动递减）。
// 如果不用volatile，编译器可能会优化掉对这些寄存器的重复访问，导致硬件操作失效。


// 2. 处理中断服务程序（ISR）中访问的全局变量
// 中断服务程序是硬件触发的、会打断当前程序执行流程的特殊函数，它和主程序共享全局变量时，这个全局变量必须用volatile修饰。
// 原因：主程序中的变量如果被编译器缓存到寄存器，中断服务程序修改的是内存中的变量值，主程序无法感知到这个变化。

// 3. （注意：有限制）多线程中共享变量（不推荐单独使用）
// 很多新手会误以为volatile可以解决多线程同步问题，但这是错误的。
// volatile只能保证「每次从内存读取最新值」，但无法保证「操作的原子性」和「内存可见性的完整语义」（比如指令重排）。
// 比如多线程中执行volatile int a = a + 1;，这个操作不是原子的（分为读取、加 1、写入三步），依然会出现线程安全问题，需要配合mutex、atomic等同步机制。
// C++11 及以后，多线程共享变量优先使用std::atomic，而不是volatile。


void VolatileClass::Test()
{
    
}
